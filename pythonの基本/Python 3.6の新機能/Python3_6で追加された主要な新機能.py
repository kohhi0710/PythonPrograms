# ----------------------------------------------------------------------------------------
# Python 3.6で追加された主要な新機能
# ----------------------------------------------------------------------------------------

# フォーマット文字列リテラル： いわゆる文字列補間
# 数値リテラルでのアンダースコアの使用： 「123456」を「123_567」などと記述可能
# 型注釈： 関数のパラメーター／戻り値の型に加えて、変数にも型注釈を付加可能に
# 非同期ジェネレータ： Python 3.5の非同期イテレータに加えて、非同期ジェネレータもサポートされた
# 非同期内包表記： 「async for」「await」などを内包表記中に記述可能に

# ----------------------------------------------------------------------------------------
# フォーマット文字列リテラル
# ----------------------------------------------------------------------------------------

# いわゆる「文字列補完」
# 「PEP」は「Python Enhancement Proposal」の略で「Pythonの機能追加や改善策に関する提案」のこと。
# Pythonでは「f-string」「f文字列」などと呼ばれることもある。
# フォーマット文字列リテラルは文字列を囲むクオーテーションの前に「f」を前置し、その内部では
# 「{式}」と記述することで、その部分にその式の値（例えば、変数の値）を埋め込める。

name = 'snake.net'
# {}内に記述した変数の値や式の計算結果が補完されている
print(f'name:{name}') # name:snake.net
print(f'2 ** 4 = {2 ** 4}') # 2 ** 4 = 16

# 「書式指定文字列」も使用可能(「:」以降に記述される)
# 書式指定文字列→https://docs.python.org/ja/3/library/string.html#formatstrings

# 「右寄せ（>）、正負両方の値で符号を付加（+）、
# 8桁幅（8）、3桁ごとにカンマ（,）を挿入（,）、10進数（d）」
print(f'2 ** 12 = {2 ** 12 :>+8,d}') # 2 ** 12 =   +4,096

# 「0bを前置（#）、4桁ごとにアンダースコア（_）を挿入、2進数（b）」
print(f'2 ** 12 = {2 ** 12 :#_b}') # 2 ** 12 = 0b1_0000_0000_0000

# ----------------------------------------------------------------------------------------
# 数値リテラルでのアンダースコアの利用
# ----------------------------------------------------------------------------------------

# 数値リテラル内にアンダースコア（_）を記述できるようになった（PEP 515）。
# これは、桁数の多い数値リテラルの可読性を高めるためのものだ。
# アンダースコアは基数の指定子（「0b」「0o」「0x」）の直後、数字と数字の間に挿入できる。
# ただし、リテラルの先頭と末尾に置くことはできず、連続したアンダースコアは認められない。

num = 0x_FFFF_FFFF
print(f'0xffffffff = {num:,}') # 0xffffffff = 4,294,967,295

num = 4_294_967_296
print(f'4_294_967_296 = {num:#_x}') # 4_294_967_296 = 0x1_0000_0000

# num = 1000_   # エラー(末尾のアンダースコア)
# num = _1000   # エラー(先頭のアンダースコア)
# num = 1__1000 # エラー(連続したアンダースコア)

# ----------------------------------------------------------------------------------------
# 型注釈/型ヒント機能の拡張
# ----------------------------------------------------------------------------------------

# 型注釈あるいは型ヒントと呼ばれる機能はPython 3.5で、関数の引数と戻り値型について導入されたものだが
# Python 3.6ではこれが拡張されて、変数（クラス変数、インスタンス変数を含む）についても
# 型注釈を付加できるようになった。

# 変数やパラメーターの名前に続けて「: 型名」と記述する。
# 関数の戻り値については「-> 型名」で指定する。

def foo(num:int) -> str:
    return str(num)

print(foo('string')) # エラー
print(foo(100))      # OK

num = '100'
print(foo(100))      # エラー

# 型注釈／型ヒントはあくまでも静的な型解析を行うためのものであり、pythonコマンドで
# 上記のスクリプトを実行する際には無視される。
# 型解析を行うにはmypyなどのツールを使用する必要がある。
# 上のコードには型に関するエラーが含まれてはいるが、実行は可能。
# mypyをインストールするにはpipコマンドを使用する。

# pip install -U mypy-lang
# pip install -U "typed_ast >= 0.6.3, < 0.7.0"

# ----------------------------------------------------------------------------------------
# 非同期ジェネレータ／非同期内包表記
# ----------------------------------------------------------------------------------------

# Pythonはバージョン3.4で非同期I/O処理を行うためのasyncioパッケージが導入された。
# その後、バージョン3.5でasync／await構文による非同期イテレータを記述できるようになり（PEP 492）、
# バージョン3.6ではasync／await構文による非同期ジェネレータがサポートされるようになった（PEP 525）

# ★「非同期」がつかないイテレータ(イテラブル = 反復可能オブジェクト)とジェネレータのおさらい★

# イテラブル(反復可能オブジェクト):
# 構成要素を一度に一つずつ返すことができるオブジェクト
# リストなどPythonに組み込みのデータ型や以下に示すような何らかの連続的なデータを格納し、
# それらを1つずつ取り出すことができるオブジェクトのこと

# イテレータ:
# データの流れを表現するオブジェクト
# 現在、イテラブルに含まれているどの要素を扱っているかを認識し、要素を取り出したり、
# 要素がなければそのことを（例外を通じて）通知したりできるオブジェクトのこと

# -------------------------------
# 単純なイテレータとジェネレータ
# -------------------------------

# 単純なイテラブルオブジェクト
class MyIterable():
    def __init__(self, num):
        self.data = [x for x in range(num)]
        self.idx = -1

    def next(self):
        self.idx += 1
        if self.idx >= len(self.data):
            raise StopIteration
        else:
            return self.data[self.idx]

    def __iter__(self):
        return self

#for item in MyIterable(3):
#    print(item)
        
# __init__メソッドではnumパラメーターの値に応じてデータを用意し、
# 現在の扱っている要素を示すインデックス値を初期化している（処理の都合でここでは「-1」としている）。

# __next__メソッドは要素の取り出しを行うためのメソッドであり、
# for文などでは内部的にこのメソッドが呼び出されている。
# ここでは、インデックス値をインクリメントした上で、まだデータがあればそれを返送し、
# なければ例外を発生している。__iter__メソッドは反復処理が可能なオブジェクトが必要なところで
# 自動的に呼び出されるメソッドであり、ここでは__next__メソッドによる反復処理が可能である
# 自分自身を返送している。

# 単純なジェネレータ
def MyGenerator(num):
    for item in range(num):
        yield item

for item in MyGenerator(3):
    print(item)

# ジェネレータでは「yield」により値を返送する際には、同時に制御も呼び出し側にいったん戻され、
# その後、ジェネレータが生成したイテレータに制御が移ると、
# 以前に実行したコードの直後から実行が再開される
# （上のコードであれば、for文で次のループが開始されるということだ）。
# 必要な時点で必要な計算を行い、その結果を戻すといった場合にジェネレータは役に立つ。

# ------------------
# 非同期イテレータ
# ------------------

import asyncio
import datetime

class MyAsyncIterable():
    # データを保持しないので、__init__メソッドはない。

    # イテレータとして自身を返送するメソッド
    def __aiter__(self):
        return self

    # 反復処理の中の一回の処理を実行する非同期メソッド
    async def __anext__(self):
        # コンソールに出力、ユーザー入力待ち状態に移行
        time = input('input wait time(0 to break):')
        # 入力された値を数値型に変換
        time = int(time)

        # 0が入力されたら例外を送出
        if time == 0:
            raise StopAsyncIteration()

        # await:async def文の中だけで使えるキーワード
        # awaitをつけた処理が完了するまで非同期処理の実行を待機する
        await mysleep(time)
        return time

# 1秒ごとにアスタリスクをコンソールに出力しながら、指定された秒数だけ待機する関数
async def mysleep(time):
    # 現在の時間の秒(seconds)に、timeで設定した値(コンソール入力値)を足した値を変数toにセット
    # datetime.timedelta:時刻差を扱うクラス。
    #                    日(days)、秒(seconds),マイクロ秒(microseconds)、ミリ秒(milliseconds)、分(minutes)、時(hours)、週(weeks)の
    #                    7つのステータスに、加減したい値を入力してdatetime.timedeltaインスタンスを作成した後、
    #                    datetime.datetimeインスタンスと合算する。
    #                    参考:https://www.javadrive.jp/python/date/index8.html
    to = datetime.datetime.now() + datetime.timedelta(seconds = time)

# ループ
    while True:
        # 1秒待機する
        await asyncio.sleep(1)
        # sep:文字列間に挿入する文字列。デフォルトは空白
        # end:文字列の末尾に追加する文字列。デフォルトは改行
        # flush:printで出力したい文字列を強制的に描写。処理が重いと遅れて出力される場合がある。
        print('*',sep = '',end = '',flush = True)

        # 現在の時間と変数toを比較し、現在の時間がtoよりも未来ならループを抜ける
        if datetime.datetime.now() > to:
            break
    print('')

async def main():
    aiter = MyAsyncIterable()

    async for msg in aiter:
        print('sleep time: {',msg,'} sec(s)',sep = '')

# asyncio.get_event_loop:カレントイベントループを取得。
#                        カレントスレッドにカレントイベントループがなければ自動的にイベントループを作り、
#                        それをカレントイベントループに設定する
loop = asyncio.get_event_loop()
loop.run_until_complete(main())
loop.close()
