# -----------------------------------------------------------------------------------------------------
# ラムダ式(無名関数)
# -----------------------------------------------------------------------------------------------------

# lambda式のx,yに1,2を代入し、x + yしている
x = (lambda x,y:x + y)(1,2)
print(x) # 3

# ラムダ式をaddに渡し、それに引数を入れることで計算を実行している
add = lambda x,y:x + y
x = add(2,4)
print(x) # 6

# ラムダ式のボディーにラムダ式を記述
# 「lambda x:(lambda y:x + y)」と同じ意味
# 「ラムダ式を返すラムダ式」ということになる
makeadder = lambda x:lambda y:x + y
# xに2が代入され、ラムダ式「lambda y : 2 + y」が返される
# そのラムダ式はadder2に渡される
adder2 = makeadder(2)
# ラムダ式に値「100」を渡すと、「lambda 100 : 2 + 100」となる
# 計算結果はxに渡される
x = adder2(100)
print(x) # 102

# -----------------------------------------------------------------------------------------------------
# ラムダ式とmapの組み合わせ
# -----------------------------------------------------------------------------------------------------

l = list(range(10))
print(l) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# 使い捨ての処理をインラインで記述
# map:引数に関数と反復可能なオブジェクトをとり、後者に対して連続的に関数を適用する
# リストの値を順番にラムダ式に渡し、結果をlistクラスでリスト化する
x = list(map(lambda x:x * 2,l))
print(x)

# 関数mapに名前つきの関数を渡す
# 以下のように簡単な処理であればわざわざ関数を定義するより、ラムダ式を使用したほうがよい
def dbl(x):
    return x * 2

x = list(map(dbl,l))
print(x)

# -----------------------------------------------------------------------------------------------------
# 関数filterを利用したリストのフィルタリング
# -----------------------------------------------------------------------------------------------------

# filter:受け取った関数を反復可能オブジェクトの要素に適用し、
# その値がTrueになるものだけを要素とする反復可能オブジェクトを返す
# リストの値を順番にラムダ式に渡し、x / 2の余りが0である(偶数)値をリストとして返す
# ※pythonでは「0、空文字列、要素のないリスト／辞書／タプル／集合」などもFalseとして扱われる
#   そのためラムダ式の条件にnotをつけて「x / 2 = 0 == False」を「x / 2 = 0 == True」としている
x = list(filter(lambda x: not x % 2,l))
print(x) # [0, 2, 4, 6, 8]